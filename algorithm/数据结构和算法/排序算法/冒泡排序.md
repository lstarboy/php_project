+ 今天要给大家介绍的是基于选择的排序算法，常见基于选择的排序算法有冒泡排序、插入排序、选择排序、归并排序和快速排序，我们在选择排序算法的时候，通常会根据以下几个维度来考虑：
    
    * 时间复杂度
    * 空间复杂度（对内存空间的消耗）
    * 算法的稳定性（如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变）
    我们首先从冒泡排序开始。
    
我们首先从冒泡排序开始。

+ 实现原理

 * 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较
 ，看是否满足大小关系要求，如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

 * 光看定义有点抽象，我们用图来演示，假设待排序数字是 4、5、6、3、2、1，第一次排序的流程是这样的：    
 
 <p align="center">
   <img src="https://qcdn.xueyuanjun.com/storage/uploads/images/gallery/2019-10/scaled-1680-/Fu3fHyCEEeb5taZJ1ay4UxYFtrQj.png" width="200px">
 </p>
 
 看这个图的时候要结合定义一起看，否则也比较懵逼，
 当然如果你去 VisuAlgo 上看动态图的话就更形象了：https://visualgo.net/zh/sorting，经过 n 次冒泡，
 最终完成排序（所谓冒泡，以升序来看，就是每次把待排序序列中的最大值插到已排序序列的最前面，这个过程就像冒泡一样）：
 
 <p align="center">
   <img src="https://qcdn.xueyuanjun.com/storage/uploads/images/gallery/2019-10/scaled-1680-/Fm23-ln4Glx0zwGxO3gP8_QYZz1m.png"/>
 </p>
 
 + 性能分析
     * 最后我们来看下冒泡排序的性能和稳定性：
     * 时间复杂度： O(n2)
     * 空间复杂度：只涉及相邻元素的交换，是原地排序算法
     * 算法稳定性：元素相等不会交换，是稳定的排序算法
     * 时间复杂度是 O(n2)，看起来性能并不是很好，所以我们在实践中基本不会选用冒泡算法。